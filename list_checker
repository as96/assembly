
openfile:
li $v0, 13
la $a0 filename
li $a2 0 #read only
syscall
sw $v0 filedescriptor


#Allocate buffer memory
li $v0, 9
li $a0, 160
syscall
sw $v0 filebufferstart

readfile:
li $v0 14
lw $a0, filedescriptor
lw $a1, filebufferstart
li $a2, 1000
syscall 
sw $v0 sizeoffile

printbuffer:
li $v0 4
lw $a0, filebufferstart
syscall

getinput:
#Allocate buffer memory
li $v0, 9
li $a0, 10
syscall
sw $v0 inputbufferstart
#get input
li $v0 8
lw $a0 inputbufferstart
li $a1 10
syscall

#checkList:
#for (i < size of file; i+= 10){
#  for (j = 0; j < 10, j++){
#    if (input[j] = 0x00 and file[i+j] = nl) j inlist
#    if (input[j] != file[i+j] break;
#  } 
#}
#
li $t0 0 #line counter
j line

nextline: addi $t0, $t0, 10
line:
lw $t2 sizeoffile
slt $t3, $t0, $t2 # at end of list?
beqz $t3 notInList
li $t1 0 #char counter
j char

nextchar: addi $t1, $t1, 1
char: #check one char at a time
slti $t3, $t1, 10 #at end of line?
beqz $t3 nextline
move $s0, $0
lw $t6, inputbufferstart
add $t6, $t6, $t1 #address of input char
lbu $s0, ($t6) #input char

move $s1, $0
lw $t6, filebufferstart
add $t6, $t6, $t0 #ref line offset
add $t6, $t6, $t1 #ref char offset
lbu $s1, ($t6) #reference char
#check for end of input
li $t2 0x20 #space character ######TODO: max length strings/ line ending
bne $t2, $s1 check_match
li $t2 10 #end of line character
bne $t2, $s0 check_match
j inList

#check for matching character
check_match:
beq $s0, $s1 nextchar
bne $s0, $s1 nextline

#####################################################
inList:
li $v0 4
la $a0, successmessage
syscall

j getinput

notInList:
li $v0 4
la $a0, failmessage
syscall

j getinput
#######################################################################
.data
filename: .asciiz "words.txt"
successmessage: .asciiz "Word is in puzzle"
failmessage: .asciiz "Word is not in puzzle"

inputbufferstart: .word 0

filebufferstart: .word 0
filedescriptor: .word 1
sizeoffile: .word 0
